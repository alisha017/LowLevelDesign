from abc import ABC, abstractmethod
from typing import Any, List, Set


# read data, convert to list and giving it to processor
class Source(ABC):
    @abstractmethod
    def read(self, data:Any) -> List[Any]:
        pass


# input is list, process the data and output a list
class Processor(ABC):
    @abstractmethod
    def process(self, data:List[Any]) -> List[Any]:
        pass


# take the output generated by processor and write to dest
class Destination(ABC):
    @abstractmethod
    def write(self, data:List[Any]) -> Any:
        pass


class Kafka(Source):
    def read(self, data: Set[Any]) -> List[Any]:
        return list(data)


class Cube_Processor(Processor):
    def process(self, data:List[int]):
        return list(map(lambda i: (i,  i**3), data))


class DDB(Destination):
    def write(self, data:List[Any]) -> Any:
        return {num: cube for num, cube in data}


class Connection:
    def connect(self, url, port):
        print(f"Connection established with {url} at port: {port}")


class Pipeline:
    def __init__(self, source:Source, dest:Destination, processor:Processor):
        self.source = source
        self.dest = dest
        self.processor = processor

    def run_pipeline(self, data:Any):
        to_process_data = self.source.read(data)
        processed_data = self.processor.process(to_process_data)
        write_data = self.dest.write(processed_data)
        return write_data


if __name__ == "__main__":
    # 2 --> 2^3 = 8
    data = {2,5,2,5,10,8,9,8,2,4,5}
    my_pipeline = Pipeline(Kafka(), DDB(), Cube_Processor())
    print(my_pipeline.run_pipeline(data))


